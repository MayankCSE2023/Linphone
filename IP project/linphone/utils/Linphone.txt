/*
 * Copyright (c) 2010-2020 Belledonne Communications SARL.
 *
 * This file is part of linphone-android
 * (see https://www.linphone.org).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package org.linphone.activities.main

import android.Manifest
import android.app.Dialog
import android.content.ComponentCallbacks2
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Parcelable
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.view.inputmethod.InputMethodManager
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.StringRes
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen
import androidx.core.view.doOnAttach
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.FragmentContainerView
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.navigation.NavController
import androidx.navigation.NavDestination
import androidx.navigation.findNavController
import androidx.window.layout.FoldingFeature
import coil.imageLoader
import com.google.android.gms.tasks.OnCompleteListener
import com.google.android.material.snackbar.Snackbar
import com.google.firebase.messaging.FirebaseMessaging
import java.io.UnsupportedEncodingException
import java.net.URLDecoder
import kotlin.math.abs
import kotlinx.coroutines.*
import org.linphone.LinphoneApplication.Companion.coreContext
import org.linphone.LinphoneApplication.Companion.corePreferences
import org.linphone.R
import org.linphone.activities.*
import org.linphone.activities.assistant.AssistantActivity
import org.linphone.activities.main.viewmodels.CallOverlayViewModel
import org.linphone.activities.main.viewmodels.DialogViewModel
import org.linphone.activities.main.viewmodels.SharedMainViewModel
import org.linphone.activities.navigateToDialer
import org.linphone.compatibility.Compatibility
import org.linphone.contact.ContactsUpdatedListenerStub
import org.linphone.core.AuthInfo
import org.linphone.core.AuthMethod
import org.linphone.core.Core
import org.linphone.core.CoreListenerStub
import org.linphone.core.CorePreferences
import org.linphone.core.tools.Log
import org.linphone.databinding.MainActivityBinding
import org.linphone.utils.*

class MainActivity : GenericActivity(), SnackBarActivity, NavController.OnDestinationChangedListener {
    private lateinit var binding: MainActivityBinding
    private lateinit var sharedViewModel: SharedMainViewModel
    private lateinit var callOverlayViewModel: CallOverlayViewModel

    private val listener = object : ContactsUpdatedListenerStub() {
        override fun onContactsUpdated() {
            Log.i("[Main Activity] Contact(s) updated, update shortcuts")
            if (corePreferences.contactsShortcuts) {
                ShortcutsHelper.createShortcutsToContacts(this@MainActivity)
            } else if (corePreferences.chatRoomShortcuts) {
                ShortcutsHelper.createShortcutsToChatRooms(this@MainActivity)
            }
        }
    }

    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean ->
        if (isGranted) {
            // Permission granted
            android.util.Log.d("body", "granted")
        } else {
            // Permission denied
            android.util.Log.d("permission", "denied")
        }
    }

    private lateinit var tabsFragment: FragmentContainerView
    private lateinit var statusFragment: FragmentContainerView

    private var overlayX = 0f
    private var overlayY = 0f
    private var initPosX = 0f
    private var initPosY = 0f
    private var overlay: View? = null

    private val componentCallbacks = object : ComponentCallbacks2 {
        override fun onConfigurationChanged(newConfig: Configuration) { }

        override fun onLowMemory() {
            Log.w("[Main Activity] onLowMemory !")
        }

        override fun onTrimMemory(level: Int) {
            Log.w("[Main Activity] onTrimMemory called with level $level !")
            applicationContext.imageLoader.memoryCache?.clear()
        }
    }

    override fun onLayoutChanges(foldingFeature: FoldingFeature?) {
        sharedViewModel.layoutChangedEvent.value = Event(true)
    }

    private var shouldTabsBeVisibleDependingOnDestination = true
    private var shouldTabsBeVisibleDueToOrientationAndKeyboard = true

    private val authenticationRequestedEvent: MutableLiveData<Event<AuthInfo>> by lazy {
        MutableLiveData<Event<AuthInfo>>()
    }
    private var authenticationRequiredDialog: Dialog? = null

    private val coreListener: CoreListenerStub = object : CoreListenerStub() {
        override fun onAuthenticationRequested(core: Core, authInfo: AuthInfo, method: AuthMethod) {
            if (authInfo.username == null || authInfo.domain == null || authInfo.realm == null) {
                return
            }

            Log.w(
                "[Main Activity] Authentication requested for account [${authInfo.username}@${authInfo.domain}] with realm [${authInfo.realm}] using method [$method]"
            )
            authenticationRequestedEvent.value = Event(authInfo)
        }
    }

    private val keyboardVisibilityListeners = arrayListOf<AppUtils.KeyboardVisibilityListener>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // -------------------------------------------------------------------------------
        askNotificationPermission()

        FirebaseMessaging.getInstance().token
            .addOnCompleteListener(
                OnCompleteListener { task ->
                    if (!task.isSuccessful) {
                        android.util.Log.d(
                            "FCM Notify",
                            "Fetching FCM registration token failed",
                            task.exception
                        )
                        return@OnCompleteListener
                    }

                    // Get new FCM registration token
                    val token: String? = task.result
                    android.util.Log.d("FCM Token", token, task.exception)
                    Toast.makeText(this, token, Toast.LENGTH_SHORT).show()
                }
            )
        // -------------------------------------------------------------------------------

        // Must be done before the setContentView
        installSplashScreen()

        binding = DataBindingUtil.setContentView(this, R.layout.main_activity)
        binding.lifecycleOwner = this

        sharedViewModel = ViewModelProvider(this)[SharedMainViewModel::class.java]
        binding.viewModel = sharedViewModel

        callOverlayViewModel = ViewModelProvider(this)[CallOverlayViewModel::class.java]
        binding.callOverlayViewModel = callOverlayViewModel

        sharedViewModel.toggleDrawerEvent.observe(
            this
        ) {
            it.consume {
                if (binding.sideMenu.isDrawerOpen(Gravity.LEFT)) {
                    binding.sideMenu.closeDrawer(binding.sideMenuContent, true)
                } else {
                    binding.sideMenu.openDrawer(binding.sideMenuContent, true)
                }
            }
        }

        coreContext.callErrorMessageResourceId.observe(
            this
        ) {
            it.consume { message ->
                showSnackBar(message)
            }
        }

        authenticationRequestedEvent.observe(
            this
        ) {
            it.consume { authInfo ->
                showAuthenticationRequestedDialog(authInfo)
            }
        }

        if (coreContext.core.accountList.isEmpty()) {
            if (corePreferences.firstStart) {
                startActivity(Intent(this, AssistantActivity::class.java))
            }
        }

        tabsFragment = findViewById(R.id.tabs_fragment)
        statusFragment = findViewById(R.id.status_fragment)

        binding.root.doOnAttach {
            Log.i("[Main Activity] Report UI has been fully drawn (TTFD)")
            try {
                reportFullyDrawn()
            } catch (se: SecurityException) {
                Log.e("[Main Activity] Security exception when doing reportFullyDrawn(): $se")
            }
        }
    }

    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)

        if (intent != null) {
            Log.d("[Main Activity] Found new intent")
            handleIntentParams(intent)
        }
    }

    override fun onResume() {
        super.onResume()
        coreContext.contactsManager.addListener(listener)
        coreContext.core.addListener(coreListener)
    }

    override fun onPause() {
        coreContext.core.removeListener(coreListener)
        coreContext.contactsManager.removeListener(listener)
        super.onPause()
    }

    override fun showSnackBar(@StringRes resourceId: Int) {
        Snackbar.make(findViewById(R.id.coordinator), resourceId, Snackbar.LENGTH_LONG).show()
    }

    override fun showSnackBar(@StringRes resourceId: Int, action: Int, listener: () -> Unit) {
        Snackbar
            .make(findViewById(R.id.coordinator), resourceId, Snackbar.LENGTH_LONG)
            .setAction(action) {
                Log.i("[Snack Bar] Action listener triggered")
                listener()
            }
            .show()
    }

    override fun showSnackBar(message: String) {
        Snackbar.make(findViewById(R.id.coordinator), message, Snackbar.LENGTH_LONG).show()
    }

    override fun onPostCreate(savedInstanceState: Bundle?) {
        super.onPostCreate(savedInstanceState)

        registerComponentCallbacks(componentCallbacks)
        findNavController(R.id.nav_host_fragment).addOnDestinationChangedListener(this)

        binding.rootCoordinatorLayout.setKeyboardInsetListener { keyboardVisible ->
            val portraitOrientation = resources.configuration.orientation != Configuration.ORIENTATION_LANDSCAPE
            Log.i(
                "[Main Activity] Keyboard is ${if (keyboardVisible) "visible" else "invisible"}, orientation is ${if (portraitOrientation) "portrait" else "landscape"}"
            )
            shouldTabsBeVisibleDueToOrientationAndKeyboard = !portraitOrientation || !keyboardVisible
            updateTabsFragmentVisibility()

            for (listener in keyboardVisibilityListeners) {
                listener.onKeyboardVisibilityChanged(keyboardVisible)
            }
        }

        initOverlay()

        if (intent != null) {
            Log.d("[Main Activity] Found post create intent")
            handleIntentParams(intent)
        }
    }

    override fun onDestroy() {
        findNavController(R.id.nav_host_fragment).removeOnDestinationChangedListener(this)
        unregisterComponentCallbacks(componentCallbacks)
        super.onDestroy()
    }

    override fun onDestinationChanged(
        controller: NavController,
        destination: NavDestination,
        arguments: Bundle?
    ) {
        hideKeyboard()
        if (statusFragment.visibility == View.GONE) {
            statusFragment.visibility = View.VISIBLE
        }

        shouldTabsBeVisibleDependingOnDestination = when (destination.id) {
            R.id.masterCallLogsFragment, R.id.masterContactsFragment, R.id.dialerFragment, R.id.masterChatRoomsFragment ->
                true
            else -> false
        }
        updateTabsFragmentVisibility()
    }

    fun addKeyboardVisibilityListener(listener: AppUtils.KeyboardVisibilityListener) {
        keyboardVisibilityListeners.add(listener)
    }

    fun removeKeyboardVisibilityListener(listener: AppUtils.KeyboardVisibilityListener) {
        keyboardVisibilityListeners.remove(listener)
    }

    fun hideKeyboard() {
        currentFocus?.hideKeyboard()
    }

    fun showKeyboard() {
        // Requires a text field to have the focus
        if (currentFocus != null) {
            (getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager)
                .showSoftInput(currentFocus, 0)
        } else {
            Log.w("[Main Activity] Can't show the keyboard, no focused view")
        }
    }

    fun hideStatusFragment(hide: Boolean) {
        statusFragment.visibility = if (hide) View.GONE else View.VISIBLE
    }

    private fun updateTabsFragmentVisibility() {
        tabsFragment.visibility = if (shouldTabsBeVisibleDependingOnDestination && shouldTabsBeVisibleDueToOrientationAndKeyboard) View.VISIBLE else View.GONE
    }

    private fun handleIntentParams(intent: Intent) {
        Log.i(
            "[Main Activity] Handling intent with action [${intent.action}], type [${intent.type}] and data [${intent.data}]"
        )

        when (intent.action) {
            Intent.ACTION_MAIN -> handleMainIntent(intent)
            Intent.ACTION_SEND, Intent.ACTION_SENDTO -> {
                if (intent.type == "text/plain") {
                    handleSendText(intent)
                } else {
                    lifecycleScope.launch {
                        handleSendFile(intent)
                    }
                }
            }
            Intent.ACTION_SEND_MULTIPLE -> {
                lifecycleScope.launch {
                    handleSendMultipleFiles(intent)
                }
            }
            Intent.ACTION_VIEW -> {
                val uri = intent.data
                if (uri != null) {
                    if (
                        intent.type == AppUtils.getString(R.string.linphone_address_mime_type) &&
                        PermissionHelper.get().hasReadContactsPermission()
                    ) {
                        val contactId =
                            coreContext.contactsManager.getAndroidContactIdFromUri(uri)
                        if (contactId != null) {
                            Log.i("[Main Activity] Found contact URI parameter in intent: $uri")
                            navigateToContact(contactId)
                        }
                    } else {
                        val stringUri = uri.toString()
                        if (stringUri.startsWith("linphone-config:")) {
                            val remoteConfigUri = stringUri.substring("linphone-config:".length)
                            if (corePreferences.autoRemoteProvisioningOnConfigUriHandler) {
                                Log.w(
                                    "[Main Activity] Remote provisioning URL set to [$remoteConfigUri], restarting Core now"
                                )
                                applyRemoteProvisioning(remoteConfigUri)
                            } else {
                                Log.i(
                                    "[Main Activity] Remote provisioning URL found [$remoteConfigUri], asking for user validation"
                                )
                                showAcceptRemoteConfigurationDialog(remoteConfigUri)
                            }
                        } else {
                            handleTelOrSipUri(uri)
                        }
                    }
                }
            }
            Intent.ACTION_DIAL, Intent.ACTION_CALL -> {
                val uri = intent.data
                if (uri != null) {
                    handleTelOrSipUri(uri)
                }
            }
            Intent.ACTION_VIEW_LOCUS -> {
                if (corePreferences.disableChat) return
                val locus = Compatibility.extractLocusIdFromIntent(intent)
                if (locus != null) {
                    Log.i("[Main Activity] Found chat room locus intent extra: $locus")
                    handleLocusOrShortcut(locus)
                }
            }
            else -> handleMainIntent(intent)
        }

        // Prevent this intent to be processed again
        intent.action = null
        intent.data = null
        val extras = intent.extras
        if (extras != null) {
            for (key in extras.keySet()) {
                intent.removeExtra(key)
            }
        }
    }

    private fun handleMainIntent(intent: Intent) {
        when {
            intent.hasExtra("ContactId") -> {
                val id = intent.getStringExtra("ContactId")
                Log.i("[Main Activity] Found contact ID in extras: $id")
                navigateToContact(id)
            }
            intent.hasExtra("Chat") -> {
                if (corePreferences.disableChat) return

                if (intent.hasExtra("RemoteSipUri") && intent.hasExtra("LocalSipUri")) {
                    val peerAddress = intent.getStringExtra("RemoteSipUri")
                    val localAddress = intent.getStringExtra("LocalSipUri")
                    Log.i(
                        "[Main Activity] Found chat room intent extra: local SIP URI=[$localAddress], peer SIP URI=[$peerAddress]"
                    )
                    navigateToChatRoom(localAddress, peerAddress)
                } else {
                    Log.i("[Main Activity] Found chat intent extra, go to chat rooms list")
                    navigateToChatRooms()
                }
            }
            intent.hasExtra("Dialer") -> {
                Log.i("[Main Activity] Found dialer intent extra, go to dialer")
                val isTransfer = intent.getBooleanExtra("Transfer", false)
                sharedViewModel.pendingCallTransfer = isTransfer
                navigateToDialer()
            }
            intent.hasExtra("Contacts") -> {
                Log.i("[Main Activity] Found contacts intent extra, go to contacts list")
                val isTransfer = intent.getBooleanExtra("Transfer", false)
                sharedViewModel.pendingCallTransfer = isTransfer
                navigateToContacts()
            }
            else -> {
                val core = coreContext.core
                val call = core.currentCall ?: core.calls.firstOrNull()
                if (call != null) {
                    Log.i(
                        "[Main Activity] Launcher clicked while there is at least one active call, go to CallActivity"
                    )
                    val callIntent = Intent(
                        this,
                        org.linphone.activities.voip.CallActivity::class.java
                    )
                    callIntent.addFlags(
                        Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_REORDER_TO_FRONT
                    )
                    startActivity(callIntent)
                }
            }
        }
    }

    private fun handleTelOrSipUri(uri: Uri) {
        Log.i("[Main Activity] Found uri: $uri to call")
        val stringUri = uri.toString()
        var addressToCall: String = stringUri

        when {
            addressToCall.startsWith("tel:") -> {
                Log.i("[Main Activity] Removing tel: prefix")
                addressToCall = addressToCall.substring("tel:".length)
            }
            addressToCall.startsWith("linphone:") -> {
                Log.i("[Main Activity] Removing linphone: prefix")
                addressToCall = addressToCall.substring("linphone:".length)
            }
            addressToCall.startsWith("sip-linphone:") -> {
                Log.i("[Main Activity] Removing linphone: sip-linphone")
                addressToCall = addressToCall.substring("sip-linphone:".length)
            }
        }

        addressToCall = addressToCall.replace("%40", "@")

        val address = coreContext.core.interpretUrl(
            addressToCall,
            LinphoneUtils.applyInternationalPrefix()
        )
        if (address != null) {
            addressToCall = address.asStringUriOnly()
        }

        Log.i("[Main Activity] Starting dialer with pre-filled URI $addressToCall")
        val args = Bundle()
        args.putString("URI", addressToCall)
        navigateToDialer(args)
    }

    private fun handleSendText(intent: Intent) {
        if (corePreferences.disableChat) return

        intent.getStringExtra(Intent.EXTRA_TEXT)?.let {
            sharedViewModel.textToShare.value = it
        }

        handleSendChatRoom(intent)
    }

    private suspend fun handleSendFile(intent: Intent) {
        if (corePreferences.disableChat) return

        Log.i("[Main Activity] Found single file to share with type ${intent.type}")

        (intent.getParcelableExtra<Parcelable>(Intent.EXTRA_STREAM) as? Uri)?.let {
            val list = arrayListOf<String>()
            coroutineScope {
                val deferred = async {
                    FileUtils.getFilePath(this@MainActivity, it)
                }
                val path = deferred.await()
                if (path != null) {
                    list.add(path)
                    Log.i("[Main Activity] Found single file to share: $path")
                }
            }
            sharedViewModel.filesToShare.value = list
        }

        // Check that the current fragment hasn't already handled the event on filesToShare
        // If it has, don't go further.
        // For example this may happen when picking a GIF from the keyboard while inside a chat room
        if (!sharedViewModel.filesToShare.value.isNullOrEmpty()) {
            handleSendChatRoom(intent)
        }
    }

    private suspend fun handleSendMultipleFiles(intent: Intent) {
        if (corePreferences.disableChat) return

        intent.getParcelableArrayListExtra<Parcelable>(Intent.EXTRA_STREAM)?.let {
            val list = arrayListOf<String>()
            coroutineScope {
                val deferred = arrayListOf<Deferred<String?>>()
                for (parcelable in it) {
                    val uri = parcelable as Uri
                    deferred.add(async { FileUtils.getFilePath(this@MainActivity, uri) })
                }
                val paths = deferred.awaitAll()
                for (path in paths) {
                    Log.i("[Main Activity] Found file to share: $path")
                    if (path != null) list.add(path)
                }
            }
            sharedViewModel.filesToShare.value = list
        }

        handleSendChatRoom(intent)
    }

    private fun handleSendChatRoom(intent: Intent) {
        if (corePreferences.disableChat) return

        val uri = intent.data
        if (uri != null) {
            Log.i("[Main Activity] Found uri: $uri to send a message to")
            val stringUri = uri.toString()
            var addressToIM: String = stringUri
            try {
                addressToIM = URLDecoder.decode(stringUri, "UTF-8")
            } catch (e: UnsupportedEncodingException) {
                Log.e("[Main Activity] UnsupportedEncodingException: $e")
            }

            when {
                addressToIM.startsWith("sms:") ->
                    addressToIM = addressToIM.substring("sms:".length)
                addressToIM.startsWith("smsto:") ->
                    addressToIM = addressToIM.substring("smsto:".length)
                addressToIM.startsWith("mms:") ->
                    addressToIM = addressToIM.substring("mms:".length)
                addressToIM.startsWith("mmsto:") ->
                    addressToIM = addressToIM.substring("mmsto:".length)
            }

            val localAddress =
                coreContext.core.defaultAccount?.params?.identityAddress?.asStringUriOnly()
            val peerAddress = coreContext.core.interpretUrl(
                addressToIM,
                LinphoneUtils.applyInternationalPrefix()
            )?.asStringUriOnly()
            Log.i(
                "[Main Activity] Navigating to chat room with local [$localAddress] and peer [$peerAddress] addresses"
            )
            navigateToChatRoom(localAddress, peerAddress)
        } else {
            val shortcutId = intent.getStringExtra("android.intent.extra.shortcut.ID") // Intent.EXTRA_SHORTCUT_ID
            if (shortcutId != null) {
                Log.i("[Main Activity] Found shortcut ID: $shortcutId")
                handleLocusOrShortcut(shortcutId)
            } else {
                Log.i("[Main Activity] Going into chat rooms list")
                navigateToChatRooms()
            }
        }
    }

    private fun handleLocusOrShortcut(id: String) {
        val split = id.split("~")
        if (split.size == 2) {
            val localAddress = split[0]
            val peerAddress = split[1]
            Log.i(
                "[Main Activity] Navigating to chat room with local [$localAddress] and peer [$peerAddress] addresses, computed from shortcut/locus id"
            )
            navigateToChatRoom(localAddress, peerAddress)
        } else {
            Log.e(
                "[Main Activity] Failed to parse shortcut/locus id: $id, going to chat rooms list"
            )
            navigateToChatRooms()
        }
    }

    private fun initOverlay() {
        overlay = binding.root.findViewById(R.id.call_overlay)
        val callOverlay = overlay
        callOverlay ?: return

        callOverlay.setOnTouchListener { view, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    overlayX = view.x - event.rawX
                    overlayY = view.y - event.rawY
                    initPosX = view.x
                    initPosY = view.y
                }
                MotionEvent.ACTION_MOVE -> {
                    view.animate()
                        .x(event.rawX + overlayX)
                        .y(event.rawY + overlayY)
                        .setDuration(0)
                        .start()
                }
                MotionEvent.ACTION_UP -> {
                    if (abs(initPosX - view.x) < CorePreferences.OVERLAY_CLICK_SENSITIVITY &&
                        abs(initPosY - view.y) < CorePreferences.OVERLAY_CLICK_SENSITIVITY
                    ) {
                        view.performClick()
                    }
                }
                else -> return@setOnTouchListener false
            }
            true
        }

        callOverlay.setOnClickListener {
            coreContext.onCallOverlayClick()
        }
    }

    private fun applyRemoteProvisioning(remoteConfigUri: String) {
        coreContext.core.provisioningUri = remoteConfigUri
        coreContext.core.stop()
        coreContext.core.start()
    }

    private fun showAcceptRemoteConfigurationDialog(remoteConfigUri: String) {
        val dialogViewModel = DialogViewModel(
            remoteConfigUri,
            getString(R.string.dialog_apply_remote_provisioning_title)
        )
        val dialog = DialogUtils.getDialog(this, dialogViewModel)

        dialogViewModel.showCancelButton {
            Log.i("[Main Activity] User cancelled remote provisioning config")
            dialog.dismiss()
        }

        val okLabel = getString(
            R.string.dialog_apply_remote_provisioning_button
        )
        dialogViewModel.showOkButton(
            {
                Log.w(
                    "[Main Activity] Remote provisioning URL set to [$remoteConfigUri], restarting Core now"
                )
                applyRemoteProvisioning(remoteConfigUri)
                dialog.dismiss()
            },
            okLabel
        )

        dialog.show()
    }

    private fun showAuthenticationRequestedDialog(
        authInfo: AuthInfo
    ) {
        authenticationRequiredDialog?.dismiss()

        val accountFound = coreContext.core.accountList.find {
            it.params.identityAddress?.username == authInfo.username && it.params.identityAddress?.domain == authInfo.domain
        }
        if (accountFound == null) {
            Log.w("[Main Activity] Failed to find account matching auth info, aborting auth dialog")
            return
        }

        val identity = "${authInfo.username}@${authInfo.domain}"
        Log.i("[Main Activity] Showing authentication required dialog for account [$identity]")

        val dialogViewModel = DialogViewModel(
            getString(R.string.dialog_authentication_required_message, identity),
            getString(R.string.dialog_authentication_required_title)
        )
        dialogViewModel.showPassword = true
        dialogViewModel.passwordTitle = getString(
            R.string.settings_password_protection_dialog_input_hint
        )
        val dialog = DialogUtils.getDialog(this, dialogViewModel)

        dialogViewModel.showCancelButton {
            dialog.dismiss()
            authenticationRequiredDialog = null
        }

        dialogViewModel.showOkButton(
            {
                Log.i(
                    "[Main Activity] Updating password for account [$identity] using auth info [$authInfo]"
                )
                val newPassword = dialogViewModel.password
                authInfo.password = newPassword
                coreContext.core.addAuthInfo(authInfo)

                coreContext.core.refreshRegisters()

                dialog.dismiss()
                authenticationRequiredDialog = null
            },
            getString(R.string.dialog_authentication_required_change_password_label)
        )

        dialog.show()
        authenticationRequiredDialog = dialog
    }

    private fun askNotificationPermission() {
        // Check for API level 33 (TIRAMISU) or higher
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(
                    this,
                    Manifest.permission.RECEIVE_BOOT_COMPLETED
                ) == PackageManager.PERMISSION_GRANTED
            ) {
                // Permission granted, FCM SDK (and your app) can post notifications.
            } else if (ActivityCompat.shouldShowRequestPermissionRationale(
                    this,
                    Manifest.permission.RECEIVE_BOOT_COMPLETED
                )
            ) {
                // Display an educational UI explaining to the user the features that will be enabled
                // by granting the RECEIVE_BOOT_COMPLETED permission. Provide "OK" and "No thanks" buttons.
                // If the user selects "OK," directly request the permission. If "No thanks," continue without notifications.
                // For simplicity, you can use a Toast or AlertDialog to explain the rationale.
            } else {
                // Directly ask for the permission
                requestPermissionLauncher.launch(Manifest.permission.RECEIVE_BOOT_COMPLETED)
            }
        }
    }
}

//-------------------------------------------------------------------------------------------------------------------------------------//

// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        google()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        maven {
            url "https://www.jitpack.io"
        } // for com.github.chrisbanes:PhotoView
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.3.2'
      classpath 'com.google.gms:google-services:4.3.15'
        classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.8.21'
       classpath 'com.google.firebase:firebase-crashlytics-gradle:2.9.6'

    }
}



task clean(type: Delete) {
    delete rootProject.buildDir
}

//-----------------------------------------------------------------------------------------------------------------//

plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'kotlin-kapt'
    id 'org.jlleitschuh.gradle.ktlint' version '11.3.1'
    id 'org.jetbrains.kotlin.android'
    id("com.google.gms.google-services")
}

def appVersionName = "5.3.0"
def appVersionCode = 52000

def packageName = "org.linphone"

def firebaseAvailable = new File(projectDir.absolutePath +'/google-services.json').exists()

def crashlyticsAvailable = new File(projectDir.absolutePath +'/google-services.json').exists() && new File(LinphoneSdkBuildDir + '/libs/').exists() && new File(LinphoneSdkBuildDir + '/libs-debug/').exists()

def extractNativeLibs = false

if (firebaseAvailable) {
    apply plugin: 'com.google.gms.google-services'
}

def gitBranch = new ByteArrayOutputStream()
task getGitVersion() {
    def gitVersion = appVersionName
    def gitVersionStream = new ByteArrayOutputStream()
    def gitCommitsCount = new ByteArrayOutputStream()
    def gitCommitHash = new ByteArrayOutputStream()

    try {
        exec {
            executable "git" args "describe", "--abbrev=0"
            standardOutput = gitVersionStream
        }
        exec {
            executable "git" args "rev-list", gitVersionStream.toString().trim() + "..HEAD", "--count"
            standardOutput = gitCommitsCount
        }
        exec {
            executable "git" args "rev-parse", "--short", "HEAD"
            standardOutput = gitCommitHash
        }
        exec {
            executable "git" args "name-rev", "--name-only", "HEAD"
            standardOutput = gitBranch
        }

        if (gitCommitsCount.toString().toInteger() == 0) {
            gitVersion = gitVersionStream.toString().trim()
        } else {
            gitVersion = gitVersionStream.toString().trim() + "." + gitCommitsCount.toString().trim() + "+" + gitCommitHash.toString().trim()
        }
        println("Git version: " + gitVersion + " (" + appVersionCode + ")")
    } catch (ignored) {
        println("Git not found, using " + gitVersion + " (" + appVersionCode + ")")
    }
    project.version = gitVersion
}

configurations {
    customImplementation.extendsFrom implementation
}

task linphoneSdkSource() {
    doLast {
        configurations.customImplementation.getIncoming().each {
            it.getResolutionResult().allComponents.each {
                if (it.id.getDisplayName().contains("linphone-sdk-android")) {
                    println 'Linphone SDK used is ' + it.moduleVersion.version + ' from ' + it.properties["repositoryName"]
                }
            }
        }
    }
}

project.tasks['preBuild'].dependsOn 'getGitVersion'
project.tasks['preBuild'].dependsOn 'linphoneSdkSource'

android {
    compileOptions {
        sourceCompatibility = 17
        targetCompatibility = 17
    }

    compileSdkVersion 34
    defaultConfig {
        minSdkVersion 23
        targetSdkVersion 34
        versionCode appVersionCode
        versionName "${project.version}"
        applicationId packageName
    }

    applicationVariants.all { variant ->
        variant.outputs.all {
            outputFileName = "linphone-android-${variant.buildType.name}-${project.version}.apk"
        }

        var enableFirebaseService = "false"
        if (firebaseAvailable) {
            enableFirebaseService = "true"
        }

        // See https://developer.android.com/studio/releases/gradle-plugin#3-6-0-behavior for why extractNativeLibs is set to true in debug flavor
        if (variant.buildType.name == "release" || variant.buildType.name == "releaseWithCrashlytics") {
            variant.getMergedFlavor().manifestPlaceholders = [linphone_address_mime_type: "vnd.android.cursor.item/vnd." + packageName + ".provider.sip_address",
                                                              linphone_file_provider: packageName + ".fileprovider",
                                                              appLabel: "@string/app_name",
                                                              firebaseServiceEnabled: enableFirebaseService]
        } else {
            variant.getMergedFlavor().manifestPlaceholders = [linphone_address_mime_type: "vnd.android.cursor.item/vnd." + packageName + ".provider.sip_address",
                                                              linphone_file_provider: packageName + ".debug.fileprovider",
                                                              appLabel: "@string/app_name_debug",
                                                              firebaseServiceEnabled: enableFirebaseService]
            extractNativeLibs = true
        }
    }

    def keystorePropertiesFile = rootProject.file("keystore.properties")
    def keystoreProperties = new Properties()
    keystoreProperties.load(new FileInputStream(keystorePropertiesFile))

    signingConfigs {
        release {
            storeFile file(keystoreProperties['storeFile'])
            storePassword keystoreProperties['storePassword']
            keyAlias keystoreProperties['keyAlias']
            keyPassword keystoreProperties['keyPassword']
        }
    }

    buildTypes {
        release {
            minifyEnabled true
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'

            resValue "string", "linphone_app_branch", gitBranch.toString().trim()
            resValue "string", "sync_account_type", packageName + ".sync"
            resValue "string", "file_provider", packageName + ".fileprovider"
            resValue "string", "linphone_address_mime_type", "vnd.android.cursor.item/vnd." + packageName + ".provider.sip_address"

            if (!firebaseAvailable) {
                resValue "string", "gcm_defaultSenderId", "none"
            }

            resValue "bool", "crashlytics_enabled", "false"
        }

        releaseWithCrashlytics {
            initWith release

            resValue "bool", "crashlytics_enabled", crashlyticsAvailable.toString()

            if (crashlyticsAvailable) {
                apply plugin: 'com.google.firebase.crashlytics'

                firebaseCrashlytics {
                    nativeSymbolUploadEnabled true
                    unstrippedNativeLibsDir file(LinphoneSdkBuildDir + '/libs-debug/').toString()
                }
            }
        }

        debug {
            applicationIdSuffix ".debug"
            debuggable true
            jniDebuggable true

            resValue "string", "linphone_app_branch", gitBranch.toString().trim()
            resValue "string", "sync_account_type", packageName + ".sync"
            resValue "string", "file_provider", packageName + ".debug.fileprovider"
            resValue "string", "linphone_address_mime_type", "vnd.android.cursor.item/vnd." + packageName + ".provider.sip_address"
            resValue "bool", "crashlytics_enabled", crashlyticsAvailable.toString()

            if (!firebaseAvailable) {
                resValue "string", "gcm_defaultSenderId", "none"
            }

            if (crashlyticsAvailable) {
                apply plugin: 'com.google.firebase.crashlytics'

                firebaseCrashlytics {
                    nativeSymbolUploadEnabled false
                }
            }
        }
    }

    buildFeatures {
        dataBinding = true
    }

    namespace 'org.linphone'
    packagingOptions {
        jniLibs {
            useLegacyPackaging extractNativeLibs
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.core:core-splashscreen:1.0.1'
    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2'
    implementation 'androidx.media:media:1.6.0'
    implementation "androidx.security:security-crypto-ktx:1.1.0-alpha06"
    implementation "androidx.window:window:1.2.0"
    implementation 'com.google.firebase:firebase-messaging:23.4.1'


    def emoji_version = "1.4.0"
    implementation "androidx.emoji2:emoji2:$emoji_version"
    implementation "androidx.emoji2:emoji2-emojipicker:$emoji_version"

    def nav_version = "2.7.5"
    implementation "androidx.navigation:navigation-fragment-ktx:$nav_version"
    implementation "androidx.navigation:navigation-ui-ktx:$nav_version"

    implementation "androidx.slidingpanelayout:slidingpanelayout:1.2.0"
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
    implementation "androidx.gridlayout:gridlayout:1.0.0"
    implementation 'androidx.recyclerview:recyclerview:1.3.2'
    implementation 'androidx.drawerlayout:drawerlayout:1.2.0'

    // https://github.com/material-components/material-components-android/blob/master/LICENSE Apache v2.0
    implementation 'com.google.android.material:material:1.10.0'
    // https://github.com/google/flexbox-layout/blob/main/LICENSE Apache v2.0
    implementation 'com.google.android.flexbox:flexbox:3.0.0'

    // https://github.com/coil-kt/coil/blob/main/LICENSE.txt Apache v2.0
    def coil_version = "2.4.0"
    implementation("io.coil-kt:coil:$coil_version")
    implementation("io.coil-kt:coil-gif:$coil_version")
    implementation("io.coil-kt:coil-svg:$coil_version")
    implementation("io.coil-kt:coil-video:$coil_version")

    // https://github.com/Baseflow/PhotoView/blob/master/LICENSE Apache v2.0
    implementation 'com.github.chrisbanes:PhotoView:2.3.0'

    implementation platform("com.google.firebase:firebase-bom:28.1.0")
//    implementation "com.google.firebase:firebase-analytics-ktx"
//    implementation "com.google.firebase:firebase-crashlytics-ktx"
//    implementation "com.google.firebase:firebase-messaging-ktx"
    // Add the dependency for the Firebase SDK for Google Analytics
    if (crashlyticsAvailable) {
        debugImplementation 'com.google.firebase:firebase-crashlytics-ndk'
        releaseWithCrashlyticsImplementation 'com.google.firebase:firebase-crashlytics-ndk'
        releaseCompileOnly 'com.google.firebase:firebase-crashlytics-ndk'
    } else {
        compileOnly 'com.google.firebase:firebase-crashlytics-ndk'
    }
    if (firebaseAvailable) {

        implementation 'com.google.firebase:firebase-messaging'
    }

    implementation 'org.linphone:linphone-sdk-android:5.4+'

    // Only enable leak canary prior to release
    // debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10'
}

task generateContactsXml(type: Copy) {
    from 'contacts.xml'
    into "src/main/res/xml/"
    outputs.upToDateWhen { file('src/main/res/xml/contacts.xml').exists() }
    filter {
        line -> line
                .replaceAll('%%AUTO_GENERATED%%', 'This file has been automatically generated, do not edit or commit !')
                .replaceAll('%%PACKAGE_NAME%%', packageName)

    }
}
project.tasks['preBuild'].dependsOn 'generateContactsXml'

ktlint {
    android = true
    ignoreFailures = true
}

project.tasks['preBuild'].dependsOn 'ktlintFormat'

if (crashlyticsAvailable) {
    afterEvaluate {
        assembleReleaseWithCrashlytics.finalizedBy(uploadCrashlyticsSymbolFileReleaseWithCrashlytics)
        packageReleaseWithCrashlytics.finalizedBy(uploadCrashlyticsSymbolFileReleaseWithCrashlytics)
    }
}

//------------------------------------------------------------------------------------------------------------------------//

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- To be able to display contacts list & match calling/called numbers -->
    <uses-permission android:name="android.permission.READ_CONTACTS" />
    <!-- For in-app contact edition -->
    <uses-permission android:name="android.permission.WRITE_CONTACTS" />

    <!-- Helps filling phone number and country code in assistant -->
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />

    <!-- Needed for auto start at boot and to ensure the service won't be killed by OS while in call -->
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />

    <!-- Starting Android 13 we need to ask notification permission -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>

    <!-- Needed for full screen intent in incoming call notifications -->
    <uses-permission android:name="android.permission.USE_FULL_SCREEN_INTENT" />
    <!-- To vibrate when pressing DTMF keys on numpad & incoming calls -->
    <uses-permission android:name="android.permission.VIBRATE" />

    <!-- Needed to attach file(s) in chat room fragment -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="32"/>
    <!-- Starting Android 13 you need those 3 permissions instead (https://developer.android.com/about/versions/13/behavior-changes-13) -->
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
    <uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />

    <!-- Needed to shared downloaded files if setting is on -->
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        android:maxSdkVersion="28" />

    <!-- Both permissions below are for contacts sync account, needed to store presence in native contact if enabled -->
    <uses-permission android:name="android.permission.AUTHENTICATE_ACCOUNTS" />
    <uses-permission android:name="android.permission.GET_ACCOUNTS" />

    <!-- Needed for Telecom Manager -->
    <uses-permission android:name="android.permission.MANAGE_OWN_CALLS"/>
    <uses-permission android:name="android.permission.READ_PHONE_NUMBERS" />

    <!-- Needed for overlay -->
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />

    <!-- Needed to check current Do not disturb policy -->
    <uses-permission android:name="android.permission.ACCESS_NOTIFICATION_POLICY" />
<!--    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />-->

    <!-- Needed for foreground service
    (https://developer.android.com/guide/components/foreground-services) -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
    <!-- Needed for Android 14
    https://developer.android.com/about/versions/14/behavior-changes-14#fgs-types -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_CAMERA" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MICROPHONE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_PHONE_CALL" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />

    <application
        android:name=".LinphoneApplication"
        android:allowBackup="false"
        android:enableOnBackInvokedCallback="true"
        android:icon="@mipmap/ic_launcher"
        android:label="${appLabel}"
        android:localeConfig="@xml/locales_config"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:theme="@style/AppTheme"
        android:allowNativeHeapPointerTagging="false">

        <meta-data
            android:name="com.google.android.gms.car.application"
            android:resource="@xml/automotive_app_desc"/>

        <!-- Set custom default icon. This is used when no icon is set for incoming notification messages.
     See README(https://goo.gl/l4GJaQ) for more. -->
        <meta-data
            android:name="com.google.firebase.messaging.default_notification_icon"
            android:resource="@drawable/linphone_logo" />
        <!-- Set color used with incoming notification messages. This is used when no color is set for the incoming
             notification message. See README(https://goo.gl/6BKBk7) for more. -->
        <meta-data
            android:name="com.google.firebase.messaging.default_notification_color"
            android:resource="@color/notification_led_color" />

        <activity android:name=".activities.main.MainActivity"
            android:exported="true"
            android:launchMode="singleTask"
            android:windowSoftInputMode="adjustResize"
            android:theme="@style/AppSplashScreenTheme">
            <nav-graph android:value="@navigation/main_nav_graph" />

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <meta-data
                android:name="android.app.shortcuts"
                android:resource="@xml/shortcuts" />

            <intent-filter>
                <action android:name="android.intent.action.VIEW_LOCUS" />
            </intent-filter>

            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="text/*" />
                <data android:mimeType="image/*" />
                <data android:mimeType="audio/*" />
                <data android:mimeType="video/*" />
                <data android:mimeType="application/*" />
            </intent-filter>

            <intent-filter>
                <action android:name="android.intent.action.SEND_MULTIPLE" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="image/*" />
                <data android:mimeType="audio/*" />
                <data android:mimeType="video/*" />
                <data android:mimeType="application/*" />
            </intent-filter>

            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.BROWSABLE" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="${linphone_address_mime_type}" />
            </intent-filter>

            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <action android:name="android.intent.action.DIAL" />
                <action android:name="android.intent.action.CALL" />
                <action android:name="android.intent.action.CALL_BUTTON" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data android:scheme="tel" />
                <data android:scheme="sip" />
                <data android:scheme="sips" />
                <data android:scheme="linphone" />
                <data android:scheme="sip-linphone" />
                <data android:scheme="linphone-config" />
            </intent-filter>

            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <action android:name="android.intent.action.SENDTO" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="sms" />
                <data android:scheme="smsto" />
                <data android:scheme="mms" />
                <data android:scheme="mmsto" />
            </intent-filter>
        </activity>

        <activity android:name=".activities.assistant.AssistantActivity"
            android:windowSoftInputMode="adjustResize"/>

        <activity android:name=".activities.voip.CallActivity"
            android:launchMode="singleTask"
            android:turnScreenOn="true"
            android:showWhenLocked="true"
            android:resizeableActivity="true"
            android:supportsPictureInPicture="true" />

        <activity
            android:name=".activities.chat_bubble.ChatBubbleActivity"
            android:allowEmbedded="true"
            android:documentLaunchMode="always"
            android:resizeableActivity="true" />

        <!-- Services -->

        <service
            android:name=".core.CoreService"
            android:exported="false"
            android:foregroundServiceType="phoneCall|camera|microphone|dataSync"
            android:stopWithTask="false"
            android:label="@string/app_name" />

        <service
            android:name="org.linphone.core.tools.service.PushService"
            android:exported="false"
            android:foregroundServiceType="dataSync"
            android:stopWithTask="false"
            android:label="@string/app_name" />

        <service android:name="org.linphone.core.tools.firebase.FirebaseMessaging"
            android:enabled="${firebaseServiceEnabled}"
            android:exported="false">
            <intent-filter>
                <action android:name="com.google.firebase.MESSAGING_EVENT" />
            </intent-filter>
        </service>

        <service
            android:name=".notifications.MyFirebaseMessagingService"
            android:exported="false">
            <intent-filter>
                <action android:name="com.google.firebase.MESSAGING_EVENT" />
            </intent-filter>
        </service>

<!--        <service-->
<!--            android:name="org.linphone.notifications.MyFirebaseMessagingService"-->
<!--            android:exported="true">-->
<!--            <intent-filter>-->
<!--                <action android:name="com.google.firebase.MESSAGING_EVENT" />-->
<!--            </intent-filter>-->
<!--        </service>-->


        <service
            android:name=".contact.DummySyncService"
            android:exported="true">
            <intent-filter>
                <action android:name="android.content.SyncAdapter" />
            </intent-filter>

            <meta-data
                android:name="android.content.SyncAdapter"
                android:resource="@xml/sync_adapter" />
            <meta-data
                android:name="android.provider.CONTACTS_STRUCTURE"
                android:resource="@xml/contacts" />
        </service>

        <service android:name=".contact.DummyAuthenticationService"
            android:exported="true">
            <intent-filter>
                <action android:name="android.accounts.AccountAuthenticator" />
            </intent-filter>

            <meta-data
                android:name="android.accounts.AccountAuthenticator"
                android:resource="@xml/authenticator" />
        </service>

        <service android:name=".telecom.TelecomConnectionService"
            android:permission="android.permission.BIND_TELECOM_CONNECTION_SERVICE"
            android:exported="true">
            <intent-filter>
                <action android:name="android.telecom.ConnectionService" />
            </intent-filter>
        </service>

        <!-- Receivers -->

        <receiver android:name=".core.CorePushReceiver"
            android:exported="false">
            <intent-filter>
                <action android:name="org.linphone.core.action.PUSH_RECEIVED"/>
            </intent-filter>
        </receiver>

        <receiver
            android:name=".notifications.NotificationBroadcastReceiver"
            android:enabled="true"
            android:exported="false" />

        <receiver android:name=".core.BootReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
            </intent-filter>
        </receiver>

        <!-- Providers -->

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${linphone_file_provider}"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/provider_paths" />
        </provider>

    </application>

</manifest>

//-----------------------------------------------------------------------------------------------------------------------------------------------//


{
  "project_info": {
    "project_number": "460124296262",
    "firebase_url": "https://linphone-android-8a563.firebaseio.com",
    "project_id": "myfirebasemessagingservi-87a5e",
    "storage_bucket": "myfirebasemessagingservi-87a5e.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:460124296262:android:57eb10d04bbd2315bda647",
        "android_client_info": {
          "package_name": "org.linphone"
        }
      },
      "oauth_client": [],
      "api_key": [
        {
          "current_key": "AIzaSyBV54I3VQ5plXUcLta2smPvC2VlWRGZUyg"
        }
      ]
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:460124296262:android:57eb10d04bbd2315bda647",
        "android_client_info": {
          "package_name": "org.linphone.debug"
        }
      },
      "oauth_client": [],
      "api_key": [
        {
          "current_key": "AIzaSyBV54I3VQ5plXUcLta2smPvC2VlWRGZUyg"
        }
      ]
    }
  ],
  "configuration_version": "1"
}

//---------------------------------------------------------------------------------------------------//
